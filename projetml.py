# -*- coding: utf-8 -*-
"""ProjetMl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p90TYKAiEolnfLCbLqbHti0h1f0Cmhn8
"""

!pip install kaggle

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d ahmedaliraja/customer-satisfaction-10k -p /content/datasets

!unzip /content/datasets/customer-satisfaction-10k.zip

import pandas as pd
df = pd.read_csv("Customer-survey-data.csv")
print(df.head())

"""# renommer les colonnes"""

import pandas as pd
df = df.rename(columns={
    'How satisfied were you with your overall delivery experience at Ali?                    1-5 where 1 = extremely dissatisfied and 5 = extremely satisfied': 'Exp_Livraison',
    'How satisfied were you with the quality of the food at Alis?                             1-5 where 1 = extremely dissatisfied and 5 = extremely satisfied': 'Qualite_Nourriture',
    'How satisfied were you with the speed of delivery at Alis?                                1-5 where 1 = extremely dissatisfied and 5 = extremely satisfied': 'Rapidite_Livraison',
    'Was your order accurate? Please respond yes or no.': 'Order_Accurate'
})
print(df.columns)

"""# Répartition des Précisions des Commandes


"""

import matplotlib.pyplot as plt

order_counts = df['Order_Accurate'].value_counts()
plt.figure(figsize=(8, 8))
plt.pie(order_counts, labels=order_counts.index, autopct='%1.1f%%', startangle=90, colors=['#66b3ff','#99ff99'])
plt.title('Répartition des Précisions des Commandes (Yes/No)')
plt.axis('equal')
plt.show()

df.describe()

#score maximum pour chaque ligne
df_max = df.iloc[:, 1:].idxmax(axis=1).value_counts().to_frame().T
plt.figure(figsize=(10, 6))
sns.barplot(data=df_max)
plt.title('Scores Maximums')
plt.xlabel('Score')
plt.ylabel('Nombre de fois où le score a été maximisé')

plt.show()

"""# Supprimer les lignes contenant des valeurs manquantes"""

df = df.dropna()

"""# Separation des features et target"""

X = df.drop(columns=['Customer', 'Was your order accurate? Please respond yes or no.'])
y = df['Was your order accurate? Please respond yes or no.']

"""# ensembles d'entraînement et de test"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Standardisation des données"""

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_1 = scaler.fit_transform(X_train)
X_test_1 = scaler.transform(X_test)

"""# Entraînement du modèle SVM"""

from sklearn.svm import SVC
svm_model = SVC(kernel='linear')
svm_model.fit(X_train_1, y_train)

"""# Prédiction et évaluation du modèle"""

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
y_pred = svm_model.predict(X_test_1)
#Score
score = accuracy_score(y_test, y_pred)
print("Score:", score)
#Matrice de confusion
conf_matrix = confusion_matrix(y_test, y_pred)
print("Matrice de Confusion :\n", conf_matrix)

"""# **Construction du modèle  arbre de decision**"""

from sklearn.tree import DecisionTreeClassifier, plot_tree
clf = DecisionTreeClassifier(max_depth =3, random_state = 42)
clf.fit(X_train_1, y_train)
y_pred = clf.predict(X_test)

import matplotlib.pyplot as plt
plt.figure(figsize=(12,8))
tree_plot = plot_tree(clf, filled=True, feature_names=['Delivery Experience', 'Quality of Food', 'Speed of Delivery'], class_names=True, rounded=True, fontsize=8)
plt.show()

"""# **Evaluation du modèle**"""

print("Model score: ",clf.score(X_test, y_test))

"""#L'apprentissage par le modèle de Régression Logistique

Construire un modèle de régression logistique
"""

from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model.fit(X_train_1, y_train)

"""Évaluer le modèle à l'aide de la matrice de confusion"""

from sklearn.metrics import confusion_matrix
y_pred = model.predict(X_test_1)
conf_matrix = confusion_matrix(y_test, y_pred)

print("y_pred=",y_pred)
print("conf_matrix=",conf_matrix)

"""Mesurer la précision"""

from sklearn.metrics import  accuracy_score, precision_score
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, pos_label='Yes')

print(f"Précision : {accuracy}")

"""#L'appretissage par le modèle KNN

Construire le modèle KNN
"""

from sklearn.neighbors import KNeighborsClassifier
k = 5  # nombre de voisins à considérer
model = KNeighborsClassifier(n_neighbors=k)
model.fit(X_train_1, y_train)

"""Evaluer le modèle à l'aide de la matrice de confusion"""

y_pred = model.predict(X_test_1)
conf_matrix = confusion_matrix(y_test, y_pred)
print("y_pred=",y_pred)
print("conf_matrix=",conf_matrix)

"""Validation croisée pour trouver la meilleure valeur de K"""

import numpy as np
from sklearn.model_selection import cross_val_score
k_values = np.arange(1, 21)


cv_scores = []


for k in k_values:

    knn_cv = KNeighborsClassifier(n_neighbors=k)

    scores = cross_val_score(knn_cv, X_train, y_train, cv=5)

    cv_scores.append(scores.mean())

# Trouver la meilleure valeur de K et le meilleur score
best_k = k_values[np.argmax(cv_scores)]
best_score = np.max(cv_scores)

print("Meilleure valeur de K:", best_k)
print("Meilleur score de validation croisée:", best_score)

"""Tracer les scores de validation"""

plt.plot(range(1, 21), cv_scores)
plt.xlabel('Nombre de voisins k')
plt.ylabel('Exactitude validée croisée')
plt.title('KNN Variation du nombre de voisins')
plt.show()

"""Mesurer la précision"""

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, pos_label='Yes')

print(f"Précision : {accuracy}")

"""#L'appretissage pa réseau de neuronne

"""

import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# definir le modele reseau de neuronne
model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='sigmoid'))


model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

import numpy as np

X_train = np.array(X_train)
y_train = np.array(y_train)
print(X_train.dtype, y_train.dtype)

print(np.unique(y_train))
from sklearn.preprocessing import LabelEncoder

label_encoder = LabelEncoder()
y_train = label_encoder.fit_transform(y_train)
print(np.unique(y_train))


history = model.fit(X_train, y_train, epochs=50, batch_size=10, validation_split=0.2)

from sklearn.preprocessing import LabelEncoder
X_test = np.array(X_test)
y_test = np.array(y_test)
print(X_test.dtype, y_test.dtype)
if isinstance(y_test[0], str):

    label_encoder = LabelEncoder()
    y_test = label_encoder.fit_transform(y_test)

loss, accuracy = model.evaluate(X_test, y_test)
print(f'Loss: {loss}')
print(f'Accuracy: {accuracy}')